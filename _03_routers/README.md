## Fastapi lesson 2

### Система контроля зависимостей

Системы контроля зависимостей используют под капотом pip и устанавливают зависимости точно также в виртуальное окружение, в котором вы работаете.
Но, через эти системы гораздо более удобно следить за версиями ваших зависимостей, а также за зависимостями зависимостей.

Системы контроля зависимостей (их всего 2):
- Pipenv
- Poetry (popular) !

Пример:

Мы работаем с проектом, в ВО к которому установлены разные библиотеки. Изначально, когда мы начинали работу, мы использовали pydantic v.1, но в процессе работы появилась pydantic v.2, которую мы теперь хотим подгрузить в наше ВО, однако если мы это сделаем в лоб, то перестанут работать другие библиотеки, которые завязаны на pydantic v.1

Единственный удобный выход из таких ситуаций предоставляют системы контроля зависимостей (а не простые виртуальные окружения)

### Работа с poetry

Poetry можно установить как на всю систему, так и внутрь конкретного проекта.

- ```pip install poetry``` установка самого poetry
- ```poetry new <new_project_name>``` создание нового проекта
- ```poetry init```  инициализация существующего проекта
- ```poetry install``` установит все зависимости из текущего файла ```pyproject.toml```, и если еще нет ```.lock-файла```, то он будет создан
- ```poetry add <package_name>``` добавляет пакет в зависимости.
- ```poetry show --tree``` печатает дерево зависимостей
- ```poetry install --sync``` синхронизировать текущее окружение с тем что необходимо установить
- ```which poety``` показать путь к текущему окружению 

### Синхронизация poetry

#### Синхронизация требуется, если мы, например, используем в своей программе ```pydantic["email"]  (ОН ЖЕ: email-validator)``` валидацию, и все работает, однако этой зависимости нет в файле ```pyprojects.toml```

В чем же дело?

Дело в том, что зависимости, которые установлены через poetry, и зависимости, которые просто установлены на наш ПК отличаются.

Мы можем посмотреть через ```pip list``` или через ```pip freeze``` какие зависимости установлены...и здесь, в том числе, можно найти ```email-validator```,
но если мы напишем команду ```poetry show --tree```, то мы увидим какие зависимости установлены сейчас в poetry, и тут нет ```email-validator```

Что же делать?

If you want to synchronize your environment – ```and ensure it matches the lock file``` – use the --sync option.

> poetry install --sync

Команда ```poetry install --sync``` синхронизирует, или точнее воссоздает наше виртуальное окружении на основании ```.lock-файла```
(для чего может потребоваться удалить часть пакетов или доустановить недостающие пакеты).
```После выполнения этой команды мы можем быть уверены, что наше виртуальное окружение работает в точном соответствии с зависимостями в .lock-файле```, и что к нему не примешено ничего лишнего!

Важно также помнить, что часть библиотек poetry устанавливает для самого себя,
поэтому запускать команду ```poetry install --sync``` если poetry установлен внутри этого окружения (в таком случае он содержит самого себя) НЕМНОГО ОПАСНО

Если синхронизировали poetry, и нам теперь необходимо доустановить пакет, то тут могут быть варианты, например:

1. Можно отдельно установить ```email-validator```
2. а можно установить его в составе pydantic: ```pydantic[email]```

Разница есть!

Мы выбираем вариант ```pydantic[email]```, т.к. если ```fastapi``` решит обновить ```pydantic```
и мы воспользуемся этим обновлением, установив его позднее,
то вместе с ним, автоматически обновится и ```pydantic[email]``` что удобно.

В противном же случае, ```email-validator``` после обновления ```pydantic``` перестанет работать
и нам придется обновлять его вручную...

```МОЖНО ВЗЯТЬ ЗА ПРАВИЛО```, что фиксировать в ```pyproject.toml``` необходимо  всё то, что вы явно используете в своём проекте (если явно пишем: ```from package import...``` или ```import package```)

```poetry add "pydantic[email]"``` // пишем в кавычках, чтобы терминал не выдавал ошибок

```ВАЖНО!```

При установке новых зависимостей или обновлении существующих, ```.lock-файл``` будет обновлён,
и вам ВАЖНО убедиться, что в этом файле ОСТАЛИСЬ ПРЕЖНИМИ те зависимости, которые вы не хотели трогать...
Например, вы проверяете, что у вас СЛУЧАЙНО не обновился fastapi, или у вас СЛУЧАЙНО не обновился uvicorn...

```content-hash = "98c7655vcv..." в .toml-файле``` - Общий хэш от всего файла, который позволяет убедиться, что данный файл никто не трогал руками.

- Типы зависимостей:
1. Зависимости, необходимые для работы приложения
2. Зависимости, необходимые для разработки приложения

Например, при разработки нам нужны:
1. Инструменты для тестирования
2. Инструменты для линтинга

Чтобы не смешивать инструменты из разных категорий,
внутри poetry существуют группы пакетов (см. файл ```pyproject.toml```, а также документацию): 
1. [tool.poetry]
2. [tool.poetry.dependencies]
3. [tool.poetry.group.dev.dependencies] // группа для разработки
4. [build-system]

#### Дополнительно:

- ```.lock-файл``` файл в котором записано, какие зависимости были установлены.
- [] c терминалом не всегда дружат. Команда ```poetry add uvicorn[standart]``` может не сработать. В таком случае используй кавычки: ```poetry add "uvicorn[standart]"```
- При желании вы можете вручную редактировать ```.toml-файл``` и указывать новые зависимости или менять версии у уже установленных зависимостей, однако ```poetry.lock``` никогда трогать нельзя. Он обновляется либо когда вы устанавливаете новые зависимости, либо командрой ```poetry lock```, при этом лучше будет передавать вместе с этой командой флаг ```--no-update```, чтобы не обновлять версии, а только перезаморозить их.
- Файлы ```.toml .lock``` нужно обязательно добавлять в Git
- В файле ```.toml``` могут находиться и конфигурации других инструментов, которые вы используете в своем проекте.
- Файл ```.lock``` нужен в Git для того, чтобы вы ставили именно те зависимости, которые вы ставили в вашем окружении до этого. (Мы хотим, чтобы при открытии своего проекта на другой машине, Poetry воссоздавал именно те зависимости, которые вами были уже проверены и точно работают)


## APIRouter
APIRouter - это такая прослойка, которая позволяет внутри FastAPI сделать ```отдельное пространство имён```!
То есть внутри питоновского модуля APIRouter заменяет собой ```app = FastAPI()``` 

## Разделение роутов на группы при помощи тегов

1 способ (при создании роутера)

```router = APIRouter(prefix="/items", tags=["Items"])```

2 способ (при регистрации роутера)

```app.include_router(items_router, tags=["Items"])```

## Важно:
1. В проекте используйте либо ТОЛЬКО абсолютные импорты, либо ТОЛЬКО относительные

